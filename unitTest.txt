# **White-Box Unit Test Analysis Report for StudyLabz Project**

## **Introduction**

This report provides a detailed white-box testing analysis for key components of the StudyLabz application. The white-box approach is utilized, meaning the tests are designed with an internal perspective of the system's code and structure.

For each selected unit, this report will:
1.  Present the source code of the **Unit Under Test**.
2.  Discuss the **Testing Methodology and Coverage Criteria** used to design the tests.
3.  Outline the specific **Test Scenarios** derived from the methodology.

---

## **1. Backend: `questionController.js` - `createQuestion` Function**

This function is critical as it handles the creation of new questions, involving validation, data sanitization, and database interaction.

### **1.1. Unit Under Test (Source Code)**

```javascript
// File: backend/controllers/questionController.js

export const createQuestion = async (req, res, next) => {
  try {
    const userId = req.user.id;
    const { text, type, options, marks, courseId, examType, image } = req.body;

    if (!text?.trim())
      return res
        .status(400)
        .json({ success: false, error: "Question text is required" });
    if (!["MCQ", "Essay"].includes(type))
      return res
        .status(400)
        .json({ success: false, error: "Invalid question type" });
    if (!marks || isNaN(marks) || marks <= 0)
      return res
        .status(400)
        .json({ success: false, error: "Marks must be a positive number" });
    if (!courseId)
      return res
        .status(400)
        .json({ success: false, error: "Course ID is required" });
    if (!examType)
      return res
        .status(400)
        .json({ success: false, error: "Exam type is required" });

    // ... (omitting validExamTypes check for brevity)

    const course = await prisma.course.findUnique({
      where: { id: Number(courseId) },
    });
    if (!course)
      return res
        .status(404)
        .json({ success: false, error: "Course not found" });

    const cleanText = sanitize(text);
    let parsedOptions = null;

    if (type === "MCQ") {
      if (!options || typeof options !== "string" || options.trim() === "") {
        return res.status(400).json({
          success: false,
          error: "MCQ options cannot be empty.",
        });
      }
      parsedOptions = sanitize(options);
    }

    const question = await prisma.question.create({
      data: {
        type,
        text: cleanText,
        options: parsedOptions,
        marks: Number(marks),
        image: image?.trim() || null,
        examType,
        course: { connect: { id: Number(courseId) } },
        createdBy: { connect: { id: userId } },
      },
      // ... include block
    });

    res.status(201).json({
      success: true,
      message: "Question created successfully",
      data: { ... }
    });
  } catch (err) {
    next(err);
  }
};
```

### **1.2. Testing Methodology and Coverage Criteria**

The internal logic of `createQuestion` is characterized by a sequence of validation checks (guards) followed by database interactions. The testing strategy is therefore designed to achieve a high degree of **Branch Coverage** and **Path Coverage** for this validation logic.

*   **Coverage Goal:** The primary goal is to achieve 100% **Branch Coverage**. This means that every `if` statement will be tested for both its `true` and `false` outcomes. This ensures that every validation rule and error path is tested. We will also aim for high **Path Coverage** by testing each failure path independently.

*   **Methodology:**
    *   **Dependency Mocking:** External dependencies, specifically the `prisma` client and the `sanitize` utility, will be mocked. This isolates the controller's logic, ensuring we are only testing the unit itself, not its dependencies.
    *   **Path Analysis:**
        1.  **Success Path:** A test will be designed to pass all validation checks, resulting in a successful database write.
        2.  **Failure Paths:** A separate test will be created for each validation `if` statement. Each test will provide input that specifically triggers that validation rule, ensuring the correct error response is sent.
        3.  **Exception Path:** A test will simulate a failure in the `prisma` database call to ensure the `try...catch` block correctly passes the error to the `next()` middleware.

### **1.3. Test Scenarios**

*   **Scenario 1: Successful Creation (Success Path)**
    *   **Description:** Tests the ideal path where all inputs are valid.
    *   **Input:** A request from an authenticated user with a body containing valid `text`, `type`, `options`, `marks`, `courseId`, and `examType`. The mocked `prisma.course.findUnique` returns a valid course.
    *   **Action:** Call the `createQuestion` function.
    *   **Expected Output:** The function returns an HTTP status of `201` with a success message and the created question data. `prisma.question.create` is called once.

*   **Scenario 2: Failure due to Missing Text (Branch 1)**
    *   **Description:** Tests the first validation guard.
    *   **Input:** Request body where `text` is an empty string or `null`.
    *   **Action:** Call the `createQuestion` function.
    *   **Expected Output:** The function returns an HTTP status of `400` with the error "Question text is required". No database methods are called.

*   **Scenario 3: Failure due to Invalid Marks (Branch 3)**
    *   **Description:** Tests the validation for the `marks` field.
    *   **Input:** Request body where `marks` is `0`, `-10`, or a non-numeric string like `"abc"`.
    *   **Action:** Call the `createQuestion` function.
    *   **Expected Output:** The function returns an HTTP status of `400` with the error "Marks must be a positive number".

*   **Scenario 4: Failure due to Course Not Found (Branch 6)**
    *   **Description:** Tests the case where the specified `courseId` does not exist.
    *   **Input:** A valid request body, but the mocked `prisma.course.findUnique` is configured to return `null`.
    *   **Action:** Call the `createQuestion` function.
    - **Expected Output:** The function returns an HTTP status of `404` with the error "Course not found".

*   **Scenario 5: Failure due to Database Exception (Exception Path)**
    *   **Description:** Tests the `try...catch` block.
    *   **Input:** A valid request body.
    *   **Action:** Call the `createQuestion` function, with the mocked `prisma.question.create` configured to throw an error.
    *   **Expected Output:** The `next()` function is called exactly once with the error object that was thrown.

---

## **2. Frontend: `ProtectedRoute.jsx` Component**

This component is a fundamental part of the application's security, deciding whether a user can access a specific route.

### **2.1. Unit Under Test (Source Code)**

```javascript
// File: frontend/src/components/ProtectedRoute.jsx

import { useLocation, Navigate } from "react-router-dom";
import { useStore } from "../store/authStore";

const ProtectedRoute = ({ children }) => {
  const authToken = useStore((state) => state.authToken);
  const location = useLocation();

  if (!authToken) {
    return <Navigate to="/login" state={{ from: location }} replace />;
  }

  return children;
};

export default ProtectedRoute;
```

### **2.2. Testing Methodology and Coverage Criteria**

The component's logic contains a single, critical decision point: `if (!authToken)`. The testing strategy is therefore focused on ensuring both outcomes of this decision are tested thoroughly.

*   **Coverage Goal:** 100% **Branch Coverage**. This is easily achievable and essential for this component.

*   **Methodology:**
    *   **Dependency Mocking:** The `useStore` hook is the component's only external dependency and will be mocked. This allows us to control the value of `authToken` for each test case.
    *   **Path Analysis:**
        1.  **Authenticated Path:** A test will simulate the state where `authToken` has a value (is "truthy").
        2.  **Unauthenticated Path:** A test will simulate the state where `authToken` is `null` (is "falsy").

### **2.3. Test Scenarios**

*   **Scenario 1: Authenticated User Access (The `else` Path)**
    *   **Description:** Tests that a logged-in user can access the content protected by the route.
    *   **Input:** The mocked `useStore` hook returns a non-null `authToken` (e.g., `'fake-token'`). The `ProtectedRoute` wraps a child component.
    *   **Action:** Render the `ProtectedRoute` component within a router context.
    *   **Expected Output:** The child component is rendered successfully.

*   **Scenario 2: Unauthenticated User Redirect (The `if` Path)**
    *   **Description:** Tests that a logged-out user is redirected away from the protected content.
    *   **Input:** The mocked `useStore` hook returns `null`.
    *   **Action:** Render the `ProtectedRoute` component within a router context.
    *   **Expected Output:** The child component is **not** rendered. The user is instead redirected to the `/login` route.